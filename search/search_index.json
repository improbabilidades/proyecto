{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":"<p>Universidad de Costa Rica | Escuela de Ingenier\u00eda El\u00e9ctrica  IE0405 - Modelos Probabil\u00edticos de Se\u00f1ales y Sistemas  Profesores: Fabi\u00e1n Abarca Calder\u00f3n y Sebasti\u00e1n Ram\u00edrez Sand\u00ed  Primer ciclo de 2025</p>"},{"location":"#proyecto-de-programacion","title":"Proyecto de programaci\u00f3n","text":""},{"location":"#grupo-xyz","title":"Grupo XYZ","text":"<ul> <li>Nombre completo, carn\u00e9, grupo</li> <li>Nombre completo, carn\u00e9, grupo</li> <li>Nombre completo, carn\u00e9, grupo</li> </ul>"},{"location":"#resumen","title":"Resumen","text":"<p>Nostrum ipsa impedit eveniet, laborum vitae ipsam deserunt exercitationem maxime voluptatibus sapiente veniam libero facilis temporibus, culpa tempore illum blanditiis amet corporis, hic consequuntur officia in quos eveniet nihil at iusto a optio maiores? Assumenda beatae dolore in voluptates voluptatem fugit iusto, perspiciatis quos aperiam officia est at harum ab quam enim.</p> <p>Blanditiis assumenda omnis quidem placeat maxime debitis animi, excepturi esse suscipit aliquam facilis vero adipisci, ab illum est facere facilis debitis sapiente magnam? Porro excepturi minima reiciendis beatae, iste minima qui nulla culpa harum sit ad optio enim doloremque eius, laborum voluptates consequatur excepturi itaque.</p>"},{"location":"#secciones","title":"Secciones","text":"<ul> <li> <p> Datos</p> <p>Descripci\u00f3n cualitativa, estad\u00edstica descriptiva y gr\u00e1ficos de los datos obtenidos.</p> <p> Ver datos</p> </li> <li> <p> Modelos</p> <p>Ajustes de los modelos de probabilidad y sus par\u00e1metros para los datos.</p> <p> Ver modelos</p> </li> <li> <p> An\u00e1lisis</p> <p>Resultados y an\u00e1lisis de la soluci\u00f3n al problema planteado.</p> <p> Ver an\u00e1lisis</p> </li> <li> <p> Conclusiones</p> <p>Conclusiones del trabajo realizado.</p> <p> Ver conclusiones</p> </li> </ul> <p>Sobre el enunciado</p> <p>Este es el enunciado del proyecto de programaci\u00f3n de IE0405 - Modelos Probabil\u00edsticos de Se\u00f1ales y Sistemas.</p> <p>Los objetivos y una introducci\u00f3n a los temas de recopilaci\u00f3n, procesamiento, almacenamiento y modelado de datos est\u00e1n en las p\u00e1ginas siguientes. Finalmente est\u00e1n las instrucciones espec\u00edficas del proyecto, los requisitos de las entregas y las r\u00fabricas de evaluaci\u00f3n.</p> <p>Esta documentaci\u00f3n est\u00e1 creada con Material for MkDocs, una plataforma con m\u00faltiples opciones de formato.</p> <p>Borrar esta nota para la entrega del proyecto </p> <p>Contenidos de la documentaci\u00f3n del proyecto</p> <p>Para la documentaci\u00f3n de su proyecto, deben eliminar los textos del enunciado y solamente agregar la explicaci\u00f3n propia de su trabajo. Eso incluye esta secci\u00f3n y las de recopilaci\u00f3n, procesamiento y otras.</p> <p>La estructura sugerida para la documentaci\u00f3n es:</p> <ul> <li><code>problema.md</code>: Descripci\u00f3n del problema a resolver.</li> <li><code>datos.md</code>: Descripci\u00f3n cualitativa, estad\u00edstica descriptiva y gr\u00e1ficos de los datos obtenidos.</li> <li><code>modelos.md</code>: Ajustes de los modelos de probabilidad y sus par\u00e1metros para los datos.</li> <li><code>analisis.md</code>: Resultados y an\u00e1lisis de la soluci\u00f3n al problema planteado.</li> <li><code>conclusiones.md</code>: Conclusiones del trabajo realizado.</li> </ul> <p>Nota: estos archivos no existen en el repositorio original. Deben crearlos si van a utilizar esta estructura. Tambi\u00e9n deben ajustar las \"tarjetas\" en Secciones.</p> <p>En el archivo <code>mkdocs.yml</code> est\u00e1 la configuraci\u00f3n b\u00e1sica de esta documentaci\u00f3n, la cual debe ser modificada (especialmente la navegaci\u00f3n <code>nav</code>) para incluir las secciones de la documentaci\u00f3n del proyecto y sus resultados. Por ejemplo:</p> <pre><code>nav:\n  - Inicio: index.md\n  - Problema: problema.md\n  - Datos: datos.md\n  - Modelos: modelos.md\n  - An\u00e1lisis: analisis.md\n  - Conclusiones: conclusiones.md\n</code></pre> <p>En la carpeta <code>images/</code> pueden colocar im\u00e1genes como gr\u00e1ficas y similares.</p> <p>Pueden agregar la estructura de archivos y carpetas que sea necesaria para incluir la soluci\u00f3n del problema, esto incluye archivos <code>.py</code> y otros similares.</p> <p>Borrar esta nota para la entrega del proyecto </p>"},{"location":"almacenamiento/","title":"Almacenamiento de datos","text":"<p>Luego de la recopilaci\u00f3n, el an\u00e1lisis de datos t\u00edpicamente contin\u00faa con el almacenamiento de datos. Las bases de datos ofrecen almacenamiento permanente y son una soluci\u00f3n en el caso de grandes cantidades de datos.</p> <p>Nota: No siempre es necesario almacenar los datos de esta forma. A menudo es suficiente hacer el an\u00e1lisis de los datos y luego desecharlos, o guardarlos en un archivo de hojas de c\u00e1lculo (<code>.xlsx</code>, <code>.ods</code>, <code>.gsheet</code>, etc.), texto plano (<code>.csv</code>, <code>.txt</code>, etc.) u otros.</p> <p>Hay distintos tipos de bases de datos y las bases de datos relacionales son las m\u00e1s comunes.</p>"},{"location":"almacenamiento/#bases-de-datos-relacionales","title":"Bases de datos relacionales","text":"<p>Las bases de datos relacionales almacenan datos tabulares -y por tanto \"planos\" y \"no anidados\"- en tablas con columnas, tambi\u00e9n llamadas campos (fields), y filas, tambi\u00e9n llamadas registros (records). Cada tabla tiene una llave primaria (PK, primary key) que identifica de forma \u00fanica cada registro. Las tablas est\u00e1n relacionadas entre s\u00ed (de ah\u00ed el nombre relacional) por medio de llaves for\u00e1neas (FK, foreign key) que hacen referencia a un registro de otra tabla, creando una estructura l\u00f3gica entre las tablas de una misma base de datos.</p> <p>En el siguiente diagrama entidad-relaci\u00f3n (ERD) simplificado, una tabla tiene datos de estudiantes, otra tabla tiene datos de los cursos y una tercera tabla vincula cursos con estudiantes (relaci\u00f3n muchos-a-muchos, many-to-many) con llaves for\u00e1neas a las dos tablas anteriores.</p> <pre><code>---\ntitle: Ejemplo de base de datos\n---\nerDiagram\n    ESTUDIANTE }o--o{ MATRICULA : matricula\n    ESTUDIANTE {\n        string estudiante_id PK\n        string nombre\n        int edad\n        float promedio\n    }\n    CURSO {\n        string curso_id PK\n        string nombre\n    }\n    MATRICULA }o--o{ CURSO : matricula\n    MATRICULA {\n        string estudiante_id FK\n        string curso_id FK\n        string ciclo\n    }</code></pre> <p>En esta base de datos est\u00e1n almacenados todos los estudiantes que tiene un curso para un ciclo particular.</p> <p>Las bases de datos relacionales m\u00e1s utilizadas son tipo SQL (Structured Query Language), que utilizan un lenguaje especial para hacer consultas a la base de datos. Por ejemplo:</p> <pre><code>SELECT nombre, edad FROM estudiantes WHERE id = B00000;\n</code></pre> <p>devuelve los datos de <code>nombre</code> y <code>edad</code> (pero no <code>promedio</code>) del carn\u00e9 B00000 en la tabla <code>estudiantes</code>.</p> <p>Las consultas (queries) de SQL pueden ser complejas. Por ejemplo:</p> <pre><code>SELECT ESTUDIANTE.*\nFROM ESTUDIANTE\nJOIN MATRICULA ON ESTUDIANTE.estudiante_id = MATRICULA.estudiante_id\nWHERE MATRICULA.curso_id = 'IE0405' AND MATRICULA.ciclo = '2027-1';\n</code></pre> <p>devuelve todos los datos de los estudiantes matriculados en el curso IE0405 en el primer ciclo del 2027.</p> <p>En general, las bases de datos tienen transacciones del tipo: lectura, creaci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de registros (CRUD, Create, Read, Update, Delete).</p> <p>Los sistemas de administraci\u00f3n de bases de datos (DBMS, Data Base Management System) m\u00e1s populares son PostgreSQL, MySQL, SQLite, MongoDB, Redis, MariaDB y otros.</p>"},{"location":"almacenamiento/#bases-de-datos-e-interfaces-orm","title":"Bases de datos e interfaces ORM","text":"<p>Es posible utilizar otros lenguajes de programaci\u00f3n para hacer transacciones con bases de datos, por medio de un mapeador relacional de objetos (ORM, Object-Relational Mapping), una  t\u00e9cnica para \"mapear\" una tabla (y su esquema) en un objeto y utilizar la programaci\u00f3n orientada a objetos para manipular los datos, y abstraer la especificidad de distintas bases de datos utilizadas. </p> <p>El uso de bases de datos es un \u00e1rea compleja y especializada, sin embargo, hay herramientas en Python que facilitan su gesti\u00f3n.</p>"},{"location":"almacenamiento/#sqlalchemy","title":"SQLAlchemy","text":"<p>En Python existe SQLAlchemy, un poderoso paquete para interactuar con los DBMS m\u00e1s populares.</p> <p>La misma b\u00fasqueda de estudiantes matriculados en un curso para un ciclo particular en el SQL de ejemplo anterior, ahora en Python y con SQLAlchemy ser\u00eda:</p> <pre><code>students = session.query(Estudiante).join(Matricula).filter(\n    Matricula.curso_id == \"IE0405\",\n    Matricula.ciclo == \"2027-1\"\n).all()\n</code></pre> <p>En general, el ejemplo de la tabla de datos de estudiantes, cursos y matr\u00edcula mostrados anteriormente, puede ser implementado de la siguiente forma:</p> Definici\u00f3n de modelos de la base de datos<pre><code>from sqlalchemy import create_engine, Column, ForeignKey, Integer, Float, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# Crear la clase base de cada tabla\nBase = declarative_base()\n\n\n# Definir los modelos\nclass Estudiante(Base):\n    __tablename__ = \"estudiantes\"\n\n    estudiante_id = Column(String, primary_key=True)\n    nombre = Column(String)\n    edad = Column(Integer)\n    promedio = Column(Float)\n\n\nclass Curso(Base):\n    __tablename__: = \"cursos\"\n\n    curso_id = Column(String, primary_key=True)\n    nombre = Column(String)\n\n\nclass Matricula(Base):\n    __tablename__ = \"matriculas\"\n\n    estudiante_id = Column(String, ForeignKey(\"estudiantes.estudiante_id\"), primary_key=True)\n    curso_id = Column(String, ForeignKey(\"cursos.curso_id\"), primary_key=True)\n    ciclo = Column(String, primary_key=True)\n\n    # Definir relaci\u00f3n de matr\u00edcula con los modelos de estudiante y curso\n    estudiante = relationship(\"Estudiante\")\n    curso = relationship(\"Curso\")\n</code></pre> <p>Aqu\u00ed fueron creadas las tres tablas, donde <code>matriculas</code> hace referencia por medio de llaves for\u00e1neas a las llaves primarias <code>estudiantes.estudiante_id</code> y <code>cursos.curso_id</code>. En esta misma tabla n\u00f3tese tambi\u00e9n que las tres columnas tienen <code>primary_key=True</code>, lo que indica una llave primaria compuesta, para lo cual cada registro debe tener una combinaci\u00f3n \u00fanica de estudiante, curso y ciclo lectivo.</p> <p>Finalmente, hay que crear las tablas estableciendo un <code>engine</code> o referencia a la base de datos a utilizar (en este caso SQLite3) y crear una sesi\u00f3n ligada a ese <code>engine</code>, para poder ejecutar las transacciones deseadas.</p> <pre><code># Crear la conexi\u00f3n a la base de datos SQLite3\nengine = create_engine(f\"sqlite:///{name}\")\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# Crear la(s) tabla(s) en la base de datos\nBase.metadata.create_all(engine)\n</code></pre> <p>La ejecuci\u00f3n del c\u00f3digo anterior crea las tablas especificadas, pero sobreescribe cualquier base de datos existente y sus datos (ver Migraciones).</p> <p>Para el proyecto la recomendaci\u00f3n es utilizar SQLite o PostgreSQL. Una diferencia b\u00e1sica entre ambos es que SQLite3 existe como un archivo binario (por ejemplo, <code>db.sqlite3</code> o <code>data.db</code>) mientras que PostgreSQL es un programa propiamente, instalado en la computadora o servidor. Para proyectos de gran escala PostgreSQL es recomendado, sin embargo SQLite3 tiene capacidad para manejar cientos de millones de datos, as\u00ed que en nuestro proyecto no es un problema. Quiz\u00e1 hay que tener m\u00e1s cuidado de no borrar el archivo \"de un dedazo\".</p>"},{"location":"almacenamiento/#migraciones","title":"Migraciones","text":"<p>En este proyecto no est\u00e1 determinado un mecanismo fundamental de migraciones, que son necesarias en el caso, completamente usual, en el que hay que realizar una actualizaci\u00f3n en la base de datos cuando hay cambios en los modelos (clases) que definen su esquema, conservando al mismo tiempo los datos ya almacenados. Por ejemplo, para cambiar el tipo de dato de <code>estudiante_id</code> de <code>String</code> a <code>Integer</code> hay que hacer una migraci\u00f3n. </p> <p>Alembic es la forma de hacerlo con SQLAlchemy, pero no est\u00e1 dentro de los alcances del proyecto.</p>"},{"location":"atributos/","title":"R\u00fabricas de evaluaci\u00f3n","text":""},{"location":"atributos/#atributo-uh01","title":"Atributo UH01","text":"<p>Utilizaci\u00f3n de herramientas modernas de ingenier\u00eda: utiliza herramientas modernas y pertinentes para las diferentes fases de desarrollo de un proyecto.</p>"},{"location":"atributos/#a-recopilacion-de-datos","title":"(A) Recopilaci\u00f3n de datos","text":"<p>Utiliza herramientas computacionales para obtener datos masivos a partir de fuentes diversas, incluyendo archivos locales o bases de datos y otras fuentes externas como servidores remotos y APIs. El planteamiento del proyecto incluye distintas fuentes de datos para an\u00e1lisis. Herramientas t\u00edpicas incluyen paquetes de Python como \u201crequests\u201d para extraer datos de APIs o SQLAlchemy para interactuar con bases de datos.</p> <ul> <li>Supera las expectativas: La implementaci\u00f3n es capaz de obtener datos de diversas fuentes sin vicios tales como importaci\u00f3n redundante, mal manejo de errores o p\u00e9rdida de datos.</li> <li>Cumple con las expectativas: La implementaci\u00f3n es capaz de obtener datos de todas las fuentes, pero no hace un manejo apropiado de errores o hace importaciones innecesarias.</li> <li>Marginal: La implementaci\u00f3n es capaz de obtener datos de algunas fuentes, solamente.</li> <li>Por debajo de las expectativas: La implementaci\u00f3n no es capaz de obtener datos de ninguna de las fuentes indicadas.</li> </ul>"},{"location":"atributos/#b-procesamiento-de-datos","title":"(B) Procesamiento de datos","text":"<p>Utiliza herramientas computacionales para limpieza y filtrado de datos masivos y utiliza conocimientos estad\u00edsticos como criterio para selecci\u00f3n y eliminaci\u00f3n de datos espurios o aberrantes. La mayor parte de datos reales contienen este tipo de datos. El planteamiento del proyecto incluye fuentes de datos reales. Herramientas t\u00edpicas incluyen paquetes de Python como Pandas para ordenamiento de los datos.</p> <ul> <li>Supera las expectativas: La implementaci\u00f3n hace una limpieza de datos y un an\u00e1lisis estad\u00edstico descriptivo de los datos recopilados y despliega los resultados. Lo hace de forma correcta seg\u00fan est\u00e1 establecido en la columna de criterios.</li> <li>Cumple con las expectativas: La implementaci\u00f3n hace una limpieza de datos y un an\u00e1lisis estad\u00edstico descriptivo de los datos recopilados y despliega los resultados, pero omite alguna indicaci\u00f3n establecida en la columna de criterios.</li> <li>Marginal: La implementaci\u00f3n omite alguna de las tareas de limpieza de datos o de an\u00e1lisis estad\u00edstico descriptivo de los datos recopilados o del despliegue de los resultados.</li> <li>Por debajo de las expectativas: La implementaci\u00f3n no hace ni una limpieza de datos ni un an\u00e1lisis estad\u00edstico descriptivo de los datos recopilados.</li> </ul>"},{"location":"atributos/#c-visualizacion-de-datos","title":"(C) Visualizaci\u00f3n de datos","text":"<p>Utiliza herramientas computacionales para crear gr\u00e1ficas relevantes de datos masivos. Herramientas t\u00edpicas incluyen paquetes de Python como Matplotlib, Seaborn o Plotly para gr\u00e1ficos bidimensionales y tridimensionales, con una gran cantidad de opciones de configuraci\u00f3n.</p> <ul> <li>Supera las expectativas: La implementaci\u00f3n utiliza gr\u00e1ficas relacionales, de distribuci\u00f3n o categ\u00f3ricas, seg\u00fan los tipos de datos disponibles. Las gr\u00e1ficas son visualmente apropiadas seg\u00fan criterios t\u00edpicos de ingenier\u00eda (rotulaci\u00f3n, escala, composici\u00f3n visual).</li> <li>Cumple con las expectativas: La implementaci\u00f3n utiliza gr\u00e1ficas relacionales, de distribuci\u00f3n o categ\u00f3ricas, seg\u00fan los tipos de datos disponibles, pero las gr\u00e1ficas no son visualmente apropiadas seg\u00fan criterios t\u00edpicos de ingenier\u00eda (rotulaci\u00f3n, escala, composici\u00f3n visual).</li> <li>Marginal: La implementaci\u00f3n no utiliza gr\u00e1ficas relacionales, de distribuci\u00f3n o categ\u00f3ricas, seg\u00fan los tipos de datos disponibles.</li> <li>Por debajo de las expectativas: La implementaci\u00f3n no utiliza tipos de gr\u00e1ficas pertinentes para los tipos de datos disponibles, ni las gr\u00e1ficas son visualmente apropiadas seg\u00fan criterios t\u00edpicos de ingenier\u00eda (rotulaci\u00f3n, escala, composici\u00f3n visual).</li> </ul>"},{"location":"atributos/#atributo-uh02","title":"Atributo UH02","text":"<p>Utilizaci\u00f3n de herramientas modernas de ingenier\u00eda: utiliza nuevas t\u00e9cnicas, herramientas o aplicaciones seg\u00fan las necesidades y oportunidades que presenta el desarrollo de un proyecto.</p>"},{"location":"atributos/#a-solucion-funcional","title":"(A) Soluci\u00f3n funcional","text":"<p>Resuelve el problema con scripts de programaci\u00f3n</p> <ul> <li>Supera las expectativas: Con un conjunto de datos de prueba, el programa devuelve los resultados esperados, incluyendo pruebas con datos inv\u00e1lidos.</li> <li>Cumple con las expectativas: Con un conjunto de datos de prueba v\u00e1lidos, el programa devuelve los resultados esperados.</li> <li>Marginal: Uno o m\u00e1s de los resultados con datos de prueba est\u00e1n incorrectos.</li> <li>Por debajo de las expectativas: El programa no devuelve una respuesta.</li> </ul>"},{"location":"atributos/#b-convenciones","title":"(B) Convenciones","text":"<p>Se adhiere a las convenciones de escritura de c\u00f3digo.</p> <ul> <li>Supera las expectativas: La revisi\u00f3n autom\u00e1tica del c\u00f3digo no reporta ning\u00fan error en las convenciones de sintaxis del c\u00f3digo.</li> <li>Cumple con las expectativas: La revisi\u00f3n autom\u00e1tica del c\u00f3digo reporta menos de cinco errores en las convenciones de sintaxis del c\u00f3digo.</li> <li>Marginal: La revisi\u00f3n autom\u00e1tica del c\u00f3digo reporta menos de diez errores en las convenciones de sintaxis del c\u00f3digo.</li> <li>Por debajo de las expectativas: La revisi\u00f3n autom\u00e1tica del c\u00f3digo reporta m\u00e1s de diez errores en las convenciones de sintaxis del c\u00f3digo.</li> </ul>"},{"location":"atributos/#c-documentacion","title":"(C) Documentaci\u00f3n","text":"<p>Documenta la funcionalidad del paquete desarrollado.</p> <ul> <li>Supera las expectativas: La documentaci\u00f3n especifica claramente las funcionalidades existentes y adem\u00e1s es amplia en la teor\u00eda que respalda la soluci\u00f3n.</li> <li>Cumple con las expectativas: La documentaci\u00f3n especifica claramente las funcionalidades existentes.</li> <li>Marginal: La documentaci\u00f3n est\u00e1 completa, pero presenta errores de escritura (ortograf\u00eda, gram\u00e1tica).</li> <li>Por debajo de las expectativas: La documentaci\u00f3n est\u00e1 incompleta.</li> </ul>"},{"location":"atributos/#d-herramientas","title":"(D) Herramientas","text":"<p>Utiliza las herramientas de software indicadas para el proyecto.</p> <ul> <li>Supera las expectativas: Desarrollo en un entorno local (computadora personal) configurado para el lenguaje de programaci\u00f3n y uso de herramientas (Git, editor, etc.)</li> <li>Cumple con las expectativas: Desarrollo en un entorno local sin una configuraci\u00f3n completa para el lenguaje de programaci\u00f3n.</li> <li>Marginal: Desarrollo en un entorno remoto (servidor web) que no fue configurado localmente para el lenguaje de programaci\u00f3n.</li> <li>Por debajo de las expectativas: No sigui\u00f3 las especificaciones de uso del lenguaje y sus herramientas y no puede desarrollar y ejecutar c\u00f3digo.</li> </ul>"},{"location":"atributos/#e-paquete","title":"(E) Paquete","text":"<p>Desarrolla una soluci\u00f3n para un problema y entrega un paquete de Python desarrollado en el semestre.</p> <ul> <li>Supera las expectativas: Es posible para una persona usuaria instalar y utilizar el paquete. Adem\u00e1s, todos los errores y advertencias de uso del paquete est\u00e1n se\u00f1alados.</li> <li>Cumple con las expectativas: Es posible para una persona usuaria instalar y utilizar el paquete.</li> <li>Marginal: Es posible la instalaci\u00f3n del paquete, pero no funciona seg\u00fan las especificaciones.</li> <li>Por debajo de las expectativas: La instalaci\u00f3n del paquete es infructuosa y no es posible probarlo.</li> </ul>"},{"location":"atributos/#atributo-te02","title":"Atributo TE02","text":"<p>Trabajo individual y en equipo: Desempe\u00f1a el rol de trabajo de acuerdo con las expectativas establecidas por el equipo y las demandas propias del trabajo o proyecto.</p>"},{"location":"atributos/#a-presentacion","title":"(A) Presentaci\u00f3n","text":"<p>Explica apropiadamente el aporte de su trabajo dentro del proyecto.</p> <ul> <li>Supera las expectativas: Presenta apropiadamente los resultados de su trabajo y lo hace en conexi\u00f3n con el proyecto global.</li> <li>Cumple con las expectativas: Presenta apropiadamente los resultados de su trabajo, pero no lo hace en conexi\u00f3n con el proyecto global.</li> <li>Marginal: Presenta de forma deficiente los resultados de su trabajo o no lo hace en conexi\u00f3n con el proyecto global.</li> <li>Por debajo de las expectativas: No presenta apropiadamente los resultados de su trabajo.</li> </ul>"},{"location":"atributos/#b-desarrollo-colaborativo","title":"(B) Desarrollo colaborativo","text":"<p>Utiliza las herramientas apropiadas para el desarrollo colaborativo de software, en este caso Git y GitHub o repositorio remoto similar.</p> <ul> <li>Supera las expectativas: Su participaci\u00f3n es evidente en el repositorio de GitHub del proyecto, siguiendo buenas pr\u00e1cticas de manejo de versiones y documentaci\u00f3n.</li> <li>Cumple con las expectativas: Su participaci\u00f3n es evidente en el repositorio de GitHub del proyecto, pero no sigue buenas pr\u00e1cticas de manejo de versiones y documentaci\u00f3n.</li> <li>Marginal: Su participaci\u00f3n no es evidente en el repositorio de GitHub del proyecto, y no sigue buenas pr\u00e1cticas de manejo de versiones y documentaci\u00f3n.</li> <li>Por debajo de las expectativas: No participa del desarrollo colaborativo del proyecto.</li> </ul>"},{"location":"exploracion/","title":"An\u00e1lisis exploratorio de datos","text":"<p>El an\u00e1lisis exploratorio de datos (EDA, Exploratoy Data Analysis) es un paso esencial en todo trabajo de ciencia e ingenier\u00eda de datos. Como su nombre sugiere, es una investigaci\u00f3n de las caracter\u00edsticas generales de los datos y puede incluir una descripci\u00f3n cualitativa de los datos, estad\u00edstica descriptiva y gr\u00e1ficos.</p> <p>Pandas es una opci\u00f3n popular para manipular los datos obtenidos.</p>"},{"location":"exploracion/#procesamiento-y-analisis-descriptivo-con-pandas","title":"Procesamiento y an\u00e1lisis descriptivo con Pandas","text":"<p>En el <code>PyX</code> n\u00famero 2 (Py2) hay una amplia discusi\u00f3n sobre Pandas.</p> <p>Aqu\u00ed basta con decir que Pandas es el equivalente program\u00e1tico de Microsoft Office Excel y otros programas de ofim\u00e1tica de hojas de c\u00e1lculo, como Google Spreadsheets y LibreOffice Calc.</p> <p>Pandas manipula datos tabulares (filas y columnas, y en ese sentido planos) por medio del objeto <code>DataFrame</code>, que ser\u00eda equivalente a una pesta\u00f1a u hoja de Excel. Sobre los datos en este <code>DataFrame</code> es posible hacer todo tipo de operaciones y aplicar todo tipo de funciones, al igual que en Excel. </p> <p>Un ejemplo de creaci\u00f3n de un <code>DataFrame</code> es el siguiente:</p> <pre><code>import pandas as pd\n\n# Crear datos de ejemplo como un diccionario con listas\ndata = {\n    \"Nombre\": [\"Andr\u00e9s\", \"Brenda\", \"Carlos\"],\n    \"Edad\": [17, 21, 22],\n    \"Ciudad\": [\"Heredia\", \"Puntarenas\", \"Guanacaste\"],\n}\n\n# Crear el objeto DataFrame\ndf = pd.DataFrame(data)\n\n# Mostrar el DataFrame\nprint(df)\n\n# Obtener el promedio de edad\npromedio_edad = df[\"Edad\"].mean()\nprint(\"Promedio de edad:\", promedio_edad)\n</code></pre> <p>Con el resultado:</p> <pre><code>   Nombre  Edad      Ciudad\n0  Andr\u00e9s    17     Heredia\n1  Brenda    21  Puntarenas\n2  Carlos    22  Guanacaste\nPromedio de edad: 20.0\n</code></pre> <p>Quiz\u00e1 las ventajas de Pandas son la posibilidad de trabajar con grandes cantidades de datos (limitados solamente por la memoria de la computadora) con mayor rendimiento y eficiencia. Excel tiene limitaciones de filas (1.048.576) y columnas (16.384, XFD) y su desempe\u00f1o se deteriora considerablemente al aproximarse a estos l\u00edmites. Tambi\u00e9n Pandas permite la integraci\u00f3n total con los m\u00faltiples paquetes de Python para crear flujos automatizados de procesamiento de datos, incluyendo aprendizaje autom\u00e1tico e interfaces de entrada y salida (sensores, actuadores, etc.).</p> <p>Adem\u00e1s, por supuesto, Pandas es de c\u00f3digo abierto y gratis.</p>"},{"location":"exploracion/#visualizacion-de-datos","title":"Visualizaci\u00f3n de datos","text":"<p>En el <code>PyX</code> n\u00famero 3 (Py3) hay una discusi\u00f3n sobre los conceptos b\u00e1sicos de graficaci\u00f3n con Matplotlib.</p> <p>Matplotlib es popular y poderoso, pero no es la \u00fanica opci\u00f3n de graficaci\u00f3n en Python. Otras opciones populares y con buena documentaci\u00f3n son:</p> <ul> <li>Seaborn: basada en Matplotlib pero enfocada en gr\u00e1ficos estad\u00edsticos.</li> <li>Plotly: sintaxis amigable y disponible para varios lenguajes de programaci\u00f3n.</li> </ul> <p>A continuaci\u00f3n hay algunas gr\u00e1ficas con cada una de estas herramientas.</p> <p>Caracter\u00edsticas obligatorias de toda gr\u00e1fica</p> <p>Todas las gr\u00e1ficas hechas en el proyecto deben incluir:</p> <ul> <li>Nombre de los ejes</li> <li>Unidades (cuando aplica)</li> <li>T\u00edtulo descriptivo</li> </ul>"},{"location":"exploracion/#matplotlib","title":"Matplotlib","text":""},{"location":"exploracion/#seaborn","title":"Seaborn","text":""},{"location":"exploracion/#plotly","title":"Plotly","text":""},{"location":"instrucciones/","title":"Enunciado del proyecto","text":""},{"location":"instrucciones/#instrucciones","title":"Instrucciones","text":""},{"location":"instrucciones/#configuracion","title":"Configuraci\u00f3n","text":"<p>Siguiendo las instrucciones de esta documentaci\u00f3n y el archivo <code>README.md</code>, instalar y ejecutar localmente el repositorio con el problema de ejemplo. Tambi\u00e9n, habilitar el control de versiones con Git y GitHub en los repositorios de MPSS-EIE.</p>"},{"location":"instrucciones/#fuente-de-datos","title":"Fuente de datos","text":"<p>En el sitio web Kalouk estar\u00e1 disponible un API, disponible en el siguiente endpoint:</p> <ul> <li>https://kalouk.xyz/api/datos</li> </ul> <p>Cada grupo har\u00e1 solicitudes en este endpoint con el par\u00e1metro <code>grupo</code>. Si un grupo es, por ejemplo, el 000, entonces la solicitud de datos es:</p> <pre><code>GET https://kalouk.xyz/api/datos?grupo=000\n</code></pre> <p>Esto devolver\u00e1 un conjunto de datos con un formato por determinar. Con la recopilaci\u00f3n de estos datos inicia el proyecto.</p>"},{"location":"instrucciones/#consejos","title":"Consejos","text":"<ul> <li>Es posible crear nuevos archivos con scripts para la soluci\u00f3n de las preguntas planteadas. Por ejemplo: <code>pdf.py</code> para determinar una funci\u00f3n de densidad de probabilidad, <code>wss.py</code> para la estacionaridad en sentido amplio, etc.</li> <li>Lo anterior es recomendable tambi\u00e9n para \"aislar\" el trabajo en diferentes archivos cuando varias personas est\u00e1n trabajando en un mismo proyecto en Git, para as\u00ed editar de forma paralela.</li> </ul>"},{"location":"instrucciones/#requisitos","title":"Requisitos","text":"<p>La documentaci\u00f3n de ambas entregas debe cumplir con los requisitos de la siguiente p\u00e1gina.</p>"},{"location":"instrucciones/#parte-i","title":"Parte I","text":"<p>En la documentaci\u00f3n web deben presentar:</p> <ol> <li>(2%) Modelos de la base de datos (<code>models.py</code>) y tareas de recolecci\u00f3n de datos (<code>tasks.py</code>)</li> <li>(2%) Recolecci\u00f3n preliminar de datos (al menos 12 horas continuas) en la base de datos</li> <li>An\u00e1lisis exploratorio de los datos</li> <li>(2%) Gr\u00e1ficas descriptivas de las variables (histogramas y otros, cuando aplica)</li> <li>(2%) Modelos de probabilidad para los datos cuando aplica y gr\u00e1fica de la funci\u00f3n de densidad sobre el histograma de los datos</li> <li>(2%) Momentos de los modelos (promedio, varianza, desviaci\u00f3n est\u00e1ndar, inclinaci\u00f3n, kurtosis)</li> </ol>"},{"location":"instrucciones/#parte-ii","title":"Parte II","text":"<p>Los datos recopilados representan una secuencia aleatoria, por cuanto son una sucesi\u00f3n de variables muestreadas en instantes discretos de tiempo, indexados por una marca temporal. En este sentido, es necesario hacer un an\u00e1lisis de procesos aleatorios a los datos recopilados.</p> <p>Cada grupo har\u00e1 solicitudes en el siguiente endpoint. Si un grupo es, por ejemplo, el 000, entonces la solicitud de datos es:</p> <pre><code>GET https://web.kalouk.xyz/api/proceso?grupo=000\n</code></pre> <p>Esto devolver\u00e1 un conjunto de datos con un formato por determinar.</p> <p>Las asignaciones son:</p> <ol> <li> <p>(2%) \u00a1Repartir m\u00e1s estrellas! Visitar GitHub con su cuenta y colocar una estrella en todos los siguientes repositorios:</p> kalouk-web <p>Servidor web de Kalouk, donde se encuentran los datos, la API, los WebSockets y otros servicios.</p> kalouk-js <p>Componentes web para interactividad con contenidos de matem\u00e1ticas y programaci\u00f3n.</p> kalouk-mcp <p>Servidor de contexto para agentes de inteligencia artificial con el protocolo de contexto de modelos (MCP)</p> kalouk-cli <p>Interfaz de l\u00ednea de comandos de Kalouk, donde se pueden hacer solicitudes a la API y otras cosas v\u00eda terminal.</p> kalouk-xyz <p>Sitio web con presentaciones del curso usando Kalouk y Slidev.</p> improbabilidades/web <p>Sitio web con la teor\u00eda del curso usando Kalouk y Nuxt.</p> improbabilidades/proyecto <p>Este enunciado del proyecto.</p> tropicalizacion/ferias <p>Sitio web de promoci\u00f3n de las ferias del agricultor desarrollado por el TCU \"Tropicalizaci\u00f3n de la tecnolog\u00eda\".</p> simovilab/* <p>Todos los repositorios de SIMOVI.</p> </li> <li> <p>(2%) \u00a1Seguir cuentas! Visitar GitHub con su cuenta y dar \"Follow\" en todas las siguientes cuentas:</p> improbabilidades <p>Cuenta de GitHub del curso, donde esta(r\u00e1) la teor\u00eda del curso (\u00a1a partir de las transcripciones de las presentaciones que ustedes hicieron!).</p> tropicalizacion <p>Cuenta de GitHub del TCU \"Tropicalizaci\u00f3n de la tecnolog\u00eda\", donde hacemos varios proyectos relacionados con transporte p\u00fablico, ferias del agricultor y talleres educativos, entre otras cosas.</p> simovilab <p>Cuenta de GitHub del nuevo Laboratorio de Sistemas Inteligentes de Movilidad, donde hacemos varios proyectos relacionados con la movilidad y el transporte p\u00fablico.</p> fabianabarca <p>Cuenta de GitHub del profesor Fabi\u00e1n.</p> RamirezSandi <p>Cuenta de GitHub del profesor Sebasti\u00e1n.</p> </li> <li> <p>(2%) Realizar la evaluaci\u00f3n docente del profesor de cada grupo respectivo, en el link provisto por la universidad. Como evidencia, presentar una captura de pantalla del mensaje al finalizar la evaluaci\u00f3n.</p> </li> <li>(2%) Participar de la sesi\u00f3n sincr\u00f3nica/asincr\u00f3nica del tema de Cadenas de Markov (instrucciones precisas ser\u00e1n enviadas por chat y correo electr\u00f3nico). </li> <li>(12%) En el servidor web de Kalouk hay un proceso aleatorio que representa un sistema M/M/1, que es una \"m\u00e1quina\" de colas con una sola fila y un \u00fanico servidor. El archivo <code>sse-client.py</code> es un cliente de Server-Sent Events (SSE) que se conecta a este proceso aleatorio y recibe eventos de cambio de estado del sistema. El cliente imprime en la terminal los eventos recibidos. Es necesario modificar este archivo para conseguir los siguientes objetivos:<ul> <li>(1%) Durante al menos una hora, registrar los eventos de cambio de estado de un proceso aleatorio.</li> <li>(4%) Determinar experimentalmente el valor num\u00e9rico de los par\u00e1metros \\(\\Omega_i\\), \\(p_i\\) y \\(q_i\\) de la cadena de Markov, para cada estado \\(i\\).</li> <li>(4%) Determinar experimentalmente el vector de probabilidad de estado estable del sistema y sus valores num\u00e9ricos.</li> <li>(3%) Analizar los resultados obtenidos.</li> </ul> </li> </ol> <p>Nota: la determinaci\u00f3n de los valores num\u00e9ricos puede ser hecha despu\u00e9s de la recolecci\u00f3n de datos, en cuyo caso es necesario utilizar una base de datos para almacenar los eventos y hacer las consultas necesarias.</p> <p>Nota: el servidor SSE est\u00e1 en la direcci\u00f3n https://web.kalouk.xyz/sse/.</p> <p>Nota: pueden ver una prueba de funcionamiento del servidor SSE en el link https://web.kalouk.xyz/sse-test/.</p>"},{"location":"instrucciones/#notas-sobre-la-parte-ii","title":"Notas sobre la Parte II","text":"<p>Un web API RESTful como el de la Parte I es un modelo de comunicaci\u00f3n donde el cliente siempre inicia la comunicaci\u00f3n con una solicitud y el servidor responde. Cuando es necesario registrar eventos en tiempo real, un API a menudo no es la mejor opci\u00f3n pues requerir\u00eda una estrategia de polling en la que se hacen llamadas de alta frecuencia para consultar si hay cambios, y es poco eficiente. Por otra parte, en un servidor SSE (Server-Sent Event) el servidor env\u00eda eventos al cliente en una conexi\u00f3n persistente cada vez que ocurre un evento y sin que el cliente tenga que solicitarlo. Esto es \u00fatil para aplicaciones en tiempo real, como la monitorizaci\u00f3n de procesos aleatorios.</p> <p>Por esto, la Parte II del proyecto utiliza un servidor SSE para publicar eventos de cambio de estado del proceso aleatorio que representa una cadena de Markov. </p> <p>El cliente en el archivo <code>sse-client.py</code> se conecta a este servidor y recibe eventos en tiempo real, que luego se pueden procesar para obtener los par\u00e1metros del sistema M/M/1 solicitados en las instrucciones.</p> <p>A continuaci\u00f3n hay una explicaci\u00f3n del c\u00f3digo del cliente <code>sse-client.py</code> que se debe completar -junto con cualquier otro archivo adicional- para cumplir con los objetivos de la Parte II del proyecto (dar clic al s\u00edmbolo + para ver m\u00e1s detalles).</p> <p>Para ejecutar este cliente es necesario instalar las nuevas dependencias del proyecto, que se encuentran en el archivo <code>requirements.txt</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>Luego, se puede ejecutar el cliente con el siguiente comando:</p> <pre><code>python sse-client.py    \n</code></pre> <p>El cliente se conectar\u00e1 al servidor SSE y comenzar\u00e1 a recibir eventos de cambio de estado del proceso aleatorio.</p> sse-client.py<pre><code>import httpx\nfrom httpx_sse import connect_sse\nimport json\n\n\ndef handle_state_message(data): # (1)\n    try: # (2)\n        payload = json.loads(data) # (3)\n        state = int(payload.get(\"state\")) # (4)\n        if isinstance(state, int) and state &gt;= 0: # (5)\n            pass # (6)\n    except (json.JSONDecodeError, TypeError): # (7)\n        print(\"Formato de mensaje inv\u00e1lido:\", data)\n\n\ndef main(): # (8)\n    url = \"https://web.kalouk.xyz/sse/\"\n    with httpx.Client() as client: # (9)\n        with connect_sse(client, \"GET\", url) as event_source: # (10)\n            for sse in event_source.iter_sse(): # (11)\n                if sse.data: # (12)\n                    handle_state_message(sse.data) # (13)\n\n\nif __name__ == \"__main__\": # (14)\n    main()\n</code></pre> <ol> <li>Esta es la funci\u00f3n que debe ser completada para manejar los mensajes de estado del proceso aleatorio.</li> <li>Intenta hacer la decodificaci\u00f3n y el resto de la l\u00f3gica.</li> <li>Decodifica el mensaje JSON.</li> <li>Extrae el estado del proceso aleatorio con la llave <code>state</code>. Se convierte a n\u00famero entero.</li> <li>Verifica si el estado es un n\u00famero entero v\u00e1lido y mayor o igual que 0. </li> <li> Aqu\u00ed se puede implementar la l\u00f3gica para registrar el evento o realizar c\u00e1lculos adicionales.</li> <li>Captura errores de decodificaci\u00f3n JSON o tipo de dato, e imprime un mensaje de error si el formato del mensaje es inv\u00e1lido.</li> <li>Define la funci\u00f3n principal del script.</li> <li>Abre un cliente HTTP para hacer solicitudes al servidor, con el alias <code>client</code>.</li> <li>Se conecta al servidor SSE con el cliente <code>client</code> en la URL especificada, usando el m\u00e9todo <code>GET</code>. El resultado es un objeto con el alias <code>event_source</code> que permite iterar sobre los eventos SSE.</li> <li>Itera sobre los eventos SSE recibidos del servidor.</li> <li>Comprueba si el evento tiene datos. Si los tiene, llama a la funci\u00f3n <code>handle_state_message</code> para procesar el mensaje.</li> <li>La funci\u00f3n <code>handle_state_message</code> recibe el mensaje de estado del proceso aleatorio, lo decodifica y extrae el estado.</li> <li>Comprueba si el script se est\u00e1 ejecutando directamente y llama a la funci\u00f3n <code>main</code> para iniciar el proceso.</li> </ol>"},{"location":"modelado/","title":"Modelos de probabilidad de los datos","text":"<p>Una parte central del proyecto es modelar estad\u00edsticamente los datos con distribuciones de probabilidad.</p> <p>En el <code>PyX</code> n\u00famero 5 (Py5) hay una discusi\u00f3n sobre modelado de datos con SciPy y Fitter.</p> <p>En general, con el m\u00f3dulo <code>stats</code> del paquete SciPy es posible encontrar los par\u00e1metros de mejor ajuste para una distribuci\u00f3n particular utilizando el m\u00e9todo <code>fit()</code> de las clases de variables aleatorias. Por ejemplo, para una distribuci\u00f3n normal:</p> Python<pre><code>from scipy import stats\n\nparams = stats.norm.fit(data)\n\nprint(params)\n</code></pre> <p>donde <code>data</code> es un conjunto de datos univariados. N\u00f3tese, sin embargo, que no hay ninguna garant\u00eda de que la distribuci\u00f3n normal sea el mejor ajuste para los datos provistos, entonces es necesario hacer pruebas de bondad de ajuste para comparar y elegir la mejor distribuci\u00f3n. El paquete Fitter ayuda en este trabajo.</p> <p>Por ejemplo, si tenemos los siguientes dos conjuntos de datos de las variables aleatorias \\(X\\) y \\(Y\\), respectivamente:</p> <p></p> <p>Una buena intuici\u00f3n es asumir que la variable aleatoria \\(X\\) tiene una distribuci\u00f3n normal (sim\u00e9trica, concentrada alrededor de un valor central y disminuyendo la densidad al alejarse) y que la variable aleatoria \\(Y\\) tiene una distribuci\u00f3n uniforme (densidad aproximadamente equiprobable en una regi\u00f3n).</p> <p>Podemos encontrar los par\u00e1metros de mejor ajuste para las distribuciones normal y uniforme en ambos casos que, graficados sobre el histograma son:</p> <p></p> <p>Aqu\u00ed es posible confirmar la intuici\u00f3n al observar el ajuste de la funci\u00f3n de densidad de probabilidad con el histograma.</p> <p>Sin embargo, existen en SciPy Stats m\u00e1s de 80 distribuciones, entonces, \u00bfcu\u00e1l es la verdadera distribuci\u00f3n que mejor describe los datos? La mera observaci\u00f3n no es suficiente. A menudo es necesario hacer pruebas de bondad de ajuste.</p> <p>En este sentido Fitter es un paquete auxiliar ya que, seg\u00fan su documentaci\u00f3n:</p> <p>Ahora, sin ning\u00fan conocimiento sobre la distribuci\u00f3n o sus par\u00e1metros, \u00bfcu\u00e1l es la distribuci\u00f3n que mejor se ajusta a los datos? SciPy tiene 80 distribuciones y la clase Fitter las examinar\u00e1 todas, llamar\u00e1 a la funci\u00f3n de ajuste, ignorando aquellas que fallen o se queden ejecut\u00e1ndose indefinidamente, y finalmente dar\u00e1 un resumen de las mejores distribuciones en el sentido de la suma de los errores cuadrados. Lo mejor es mostrar un ejemplo:</p> <pre><code>from fitter import Fitter\nf = Fitter(data)\nf.fit()\nf.summary()\n</code></pre> <p>Proceso demandante de recursos computacionales</p> <p><code>f.fit()</code> puede tardar muchos minutos si Fitter va a probar todas las distribuciones de SciPy Stats. Es posible indicar espec\u00edficamente cu\u00e1les distribuciones deben ser evaluadas, por ejemplo:</p> <pre><code>f = Fitter(data, distributions=[\"norm\", \"expon\", \"rayleigh\", \"uniform\"])\n</code></pre> <p>o cualquier otro subconjunto de distribuciones, indicados como una lista con los nombres de las clases de SciPy Stats (disponibles con <code>from fitter import get_distributions; get_distributions()</code>).</p>"},{"location":"objetivos/","title":"Objetivos","text":""},{"location":"objetivos/#objetivo-general","title":"Objetivo general","text":"<p>Implementar una canalizaci\u00f3n de datos (pipeline) en tiempo real para procesamiento y an\u00e1lisis a partir de una fuente de datos externa, utilizando las herramientas computacionales de Python.</p>"},{"location":"objetivos/#objetivos-especificos-de-estadistica-y-probabilidad","title":"Objetivos espec\u00edficos de estad\u00edstica y probabilidad","text":"<ol> <li>Realizar an\u00e1lisis exploratorios de datos con estad\u00edstica descriptiva</li> <li>Determinar modelos de probabilidad y sus par\u00e1metros</li> <li>Graficar datos y sus modelos de probabilidad</li> <li>Analizar transformaciones de variables aleatorias</li> <li>Analizar procesos aleatorios</li> </ol>"},{"location":"objetivos/#objetivos-especificos-de-aplicacion","title":"Objetivos espec\u00edficos de aplicaci\u00f3n","text":"<ol> <li>Utilizar interfaces de programaci\u00f3n de aplicaciones (API) de forma program\u00e1tica para obtener datos de fuentes externas.</li> <li>Utilizar administradores de tareas (Celery Worker) y planificadores de tareas (Celery Beat) para ejecutar tareas peri\u00f3dicas.</li> <li>Utilizar un gestor de bases de datos (SQLite3, PostgreSQL) y un mapeador de objetos relacional (SQLAlchemy) para interactuar con bases de datos.</li> <li>Procesar los datos obtenidos para tratamiento y an\u00e1lisis.</li> <li>Utilizar herramientas estad\u00edsticas de Python para hacer an\u00e1lisis estad\u00edstico descriptivo y modelado probabil\u00edstico de los datos recopilados.</li> <li>Graficar los datos recopilados y sus an\u00e1lisis para visualizaci\u00f3n y an\u00e1lisis preliminar.</li> <li>Crear documentaci\u00f3n del proyecto en forma de p\u00e1gina web para presentaci\u00f3n al p\u00fablico en general.</li> </ol>"},{"location":"recopilacion/","title":"Recopilaci\u00f3n de datos","text":"<p>El an\u00e1lisis de datos comienza con la recopilaci\u00f3n de datos. Podr\u00edamos separar la recopilaci\u00f3n en dos grandes paradigmas:</p> <ul> <li>Procesamiento por lotes (batch processing): consiste en la recolecci\u00f3n de una gran cantidad de datos hist\u00f3ricos, t\u00edpicamente una sola vez, o con una frecuencia tan baja que cada recopilaci\u00f3n tiene una gran cantidad de datos. Ejemplos: los \"famosos\" datos de pasajeros del Titanic, los cuales necesariamente fueron recolectados una sola vez, o la informaci\u00f3n que utiliza YouTube o Netflix para entrenar sus sistemas de recomendaciones que, aunque son actualizados diariamente, contienen millones de nuevas interacciones en cada recopilaci\u00f3n.</li> <li>Procesamiento en tiempo real (real-time processing): consiste en la recolecci\u00f3n de datos al momento de su ocurrencia, esto es, basado en eventos (event-driven) o con una frecuencia de recopilaci\u00f3n tan alta que solamente algunos pocos nuevos datos, o ninguno, son obtenidos en cada muestreo. Ejemplos: datos sobre terremotos, valores diarios de los mercados de valores o mediciones de redes de sensores recopiladas cada 10 segundos.</li> </ul> <p>En medio de ambos hay una \"zona gris\", a menudo llamada procesamiento en tiempo casi real (quasi real-time processing), que captura la din\u00e1mica del sistema sin responder directamente a eventos o sin una frecuencia tan alta. Por ejemplo, la telemetr\u00eda y rastreo en veh\u00edculos de transporte p\u00fablico actualiza datos cada 15 o 20 segundos, lo cual es suficiente para tener una buena estimaci\u00f3n de su posici\u00f3n, pero no es totalmente \"en tiempo real\".</p> <p>La definici\u00f3n, entonces, var\u00eda seg\u00fan el fen\u00f3meno analizado, que puede tener cambios muy frecuentes o no. Por ejemplo: un muestreo anual podr\u00eda ser \"tiempo real\" en el an\u00e1lisis de fen\u00f3menos geol\u00f3gicos (lentos, por naturaleza).</p> <p>Definici\u00f3n informal de procesamiento en tiempo real</p> <p>Un flujo de datos en el cual el procesamiento de una nueva muestra inicia en el momento de su llegada y concluye antes de la llegada de la siguiente muestra o evento.</p>"},{"location":"recopilacion/#fuentes-de-datos","title":"Fuentes de datos","text":"<p>Los datos pueden venir de un solo archivo (ejemplo, un <code>.xlsx</code> o <code>.csv</code>), directamente de un sensor (ejemplo, un Arduino conectado a la computadora con un sensor de temperatura), o de una base de datos externa, siguiendo varios modelos de comunicaci\u00f3n posibles, explicados a continuaci\u00f3n.</p>"},{"location":"recopilacion/#modelos-de-comunicacion","title":"Modelos de comunicaci\u00f3n","text":"<p>Algunos de los modelos de comunicaci\u00f3n para compartir datos entre sistemas son:</p> <ul> <li>Solicitud/respuesta: donde una solicitud del cliente interact\u00faa con los recursos de un servidor que devuelve una respuesta. Ejemplo: HTTP (el famoso \"404 Not Found\" es uno de los c\u00f3digos de estado de respuesta posibles) o las interfaces de programaci\u00f3n de aplicaciones web (web API, Application Programming Interface) que operan sobre HTTP y conectan distintos servicios de forma program\u00e1tica. </li> <li>Publicaci\u00f3n/suscripci\u00f3n: donde un productor (producer) publica un mensaje que coloca en un canal sobre un t\u00f3pico y un intermediador de mensajes (message broker) lo distribuye a todos los procesos que est\u00e1n suscritos. Ejemplo: el monitoreo de eventos en la agricultura de precisi\u00f3n con una red de sensores conectada con MQTT. </li> <li>WebSockets: donde hay un canal de comunicaci\u00f3n bidireccional con comunicaci\u00f3n persistente. Ejemplo: en cualquier aplicaci\u00f3n de chat (WhatsApp, Telegram, etc.) o videojuegos en l\u00ednea, en las que la acci\u00f3n de un cliente es reflejada en los otros. Por ejemplo: cuando aparte \"Fulanito est\u00e1 escribiendo\u2026\" en un chat. Por su parte, HTTP es una conexi\u00f3n no persistente, a diferencia de los WebSockets.</li> <li>Otros</li> </ul> <p>Una de las soluciones m\u00e1s populares es obtener datos de fuentes externas, y hacerlo por medio de un API o interfaz de programaci\u00f3n de aplicaciones, como est\u00e1 descrito a continuaci\u00f3n.</p>"},{"location":"recopilacion/#datos-desde-fuentes-externas-con-api","title":"Datos desde fuentes externas con API","text":"<p>En el PyX n\u00famero 6 (Py6) hay una amplia explicaci\u00f3n sobre los web API y el uso del paquete <code>requests</code> de Python.</p> <p>Hay una gran cantidad de API p\u00fablicos disponibles en Public APIs para experimentar con la recolecci\u00f3n de datos.</p> <p>El siguiente es un ejemplo con el API de GitHub, donde est\u00e1 disponible la informaci\u00f3n de la cuenta de las personas registradas.</p> playground.ipynb<pre><code>import requests\n\n# Usuario(a) de GitHub\nusuario = \"fabianabarca\"\n\n# Construir la URL\napi_url = \"https://api.github.com/users/\" + usuario\n\n# Hacer la solicitud GET y guardar un \"Response\" en la variable r\nr = requests.get(api_url)\n\n# Convertir la informaci\u00f3n obtenida en JSON\ndatos = r.json()\n\n# Extraer y mostrar alg\u00fan dato particular\nprint(\"Compa\u00f1\u00eda:\", datos[\"company\"])\n\n# Resultado\n# Compa\u00f1\u00eda: Universidad de Costa Rica\n</code></pre> <p>Nota: En el archivo <code>playground.ipynb</code> (Notebook de Jupyter) de este repositorio pueden experimentar con este c\u00f3digo.</p>"},{"location":"recopilacion/#recopilacion-de-datos-en-el-proyecto","title":"Recopilaci\u00f3n de datos en el proyecto","text":"<p>Para este proyecto haremos una recopilaci\u00f3n de datos en tiempo casi real de fuentes externas con un web API y lo haremos de forma peri\u00f3dica, utilizando un administrador y planificador de tareas, para almacenarlos en una base de datos relacional.</p> <p>A continuaci\u00f3n hay una ampliaci\u00f3n de estos conceptos.</p>"},{"location":"recopilacion/#recoleccion-periodica-de-datos-con-un-planificador-de-tareas","title":"Recolecci\u00f3n peri\u00f3dica de datos con un planificador de tareas","text":"<p>A menudo es necesario realizar tareas de forma peri\u00f3dica y autom\u00e1tica. Esta gesti\u00f3n debe ser realizada con suficiente robustez para asignar correctamente qui\u00e9n va a realizar la tarea y cu\u00e1ndo la va a hacer, y c\u00f3mo lidiar con posibles problemas en su ejecuci\u00f3n. En el an\u00e1lisis de datos esta no es una tarea trivial y requiere de adecuada planificaci\u00f3n. Existen plataformas completas para esto, como Apache Airflow, pero usaremos una herramienta m\u00e1s b\u00e1sica aunque igualmente poderosa, que de hecho est\u00e1 en el coraz\u00f3n de Airflow.</p> <p>En Python es posible utilizar el paquete Celery como administrador de tareas (task manager) y como planificador de tareas (task scheduler) que \"calendariza\" tareas en frecuencias especificadas, como \"cada 60 segundos\" o \"a las 4:00 am\", o seg\u00fan otros criterios como \"el primer lunes del mes\" o \"al anochecer\".</p> <p>Por tanto, para un flujo de procesamiento de datos en tiempo real o en tiempo casi real podemos usar Celery para recopilar datos de forma program\u00e1tica, continua y peri\u00f3dica. Hay m\u00e1s detalles a continuaci\u00f3n.</p>"},{"location":"recopilacion/#administrador-de-tareas","title":"Administrador de tareas","text":"<p>Celery Worker administra la ejecuci\u00f3n de tareas de forma asincr\u00f3nica entre los \"trabajadores\" (workers) disponibles. Un \"trabajador\" puede ser simplemente un n\u00facleo de la computadora local que est\u00e1 libre para ejecutar una tarea o puede ser, por ejemplo, un servidor remoto en una configuraci\u00f3n m\u00e1s compleja.</p> <p>Asincr\u00f3nico significa que las tareas no bloquean unas a otras. Por ejemplo, en un flujo sincr\u00f3nico de tareas, una tarea es ejecutada solamente despu\u00e9s de que la anterior haya terminado. En el contexto de un administrador de tareas como Celery Worker, un flujo de tareas asincr\u00f3nico permite que m\u00faltiples tareas sean ejecutadas en paralelo o de manera independiente, sin necesidad de esperar la finalizaci\u00f3n de otras. Celery Worker se encarga de consumir tareas de una cola de mensajes, ejecutarlas y reportar sus resultados.</p>"},{"location":"recopilacion/#planificador-de-tareas","title":"Planificador de tareas","text":"<p>Celery Beat define los momentos en que las tareas son ejecutadas, es decir, es un \"calendarizador\" o \"planificador\" (scheduler). Esto es \u00fatil para crear tareas en una frecuencia definida como, por ejemplo, \"cada 15 segundos\" o \"cada 12 horas\" o \"todos los d\u00edas a las 2:00 am\" o \"el segundo mi\u00e9rcoles de cada mes\", e inclusive con base en eventos solares, como \"al amanecer\" o \"al mediod\u00eda\" (que var\u00eda seg\u00fan la ubicaci\u00f3n en el planeta y la \u00e9poca del a\u00f1o).</p>"},{"location":"recopilacion/#intermediador-de-mensajes","title":"Intermediador de mensajes","text":"<p>Cuando es necesaria la comunicaci\u00f3n entre procesos en una computadora, es necesario un intermediador de mensajes (message broker) para entregar el mensaje, pues los procesos no pueden comunicarse entre s\u00ed directamente.</p> <p>Redis es un intermediador de mensajes y base de datos tipo cach\u00e9 popular que permite varios modelos de comunicaci\u00f3n, como publicaci\u00f3n/suscripci\u00f3n. </p> <p>Redis tiene integraci\u00f3n con Celery, y es necesario para el env\u00edo de la asignaci\u00f3n de las tareas peri\u00f3dicas desde el planificador (Celery Beat) hasta el trabajador (Celery Worker).</p> <p>Hay m\u00e1s detalles en la documentaci\u00f3n de Celery.</p>"},{"location":"requisitos/","title":"Requisitos del proyecto","text":"<p>Aseg\u00farense de cumplir con cada una de las siguientes indicaciones (\u00a1son, mayormente, sencillas!).</p>"},{"location":"requisitos/#documentacion","title":"Documentaci\u00f3n","text":"<ul> <li> Exista la documentaci\u00f3n en MkDocs</li> <li> Hay una \"portada\" con informaci\u00f3n general b\u00e1sica (en <code>index.md</code>)</li> <li> Fue borrada la nota y la advertencia de la portada (en <code>index.md</code>)</li> <li> Fueron eliminadas las p\u00e1ginas del enunciado del proyecto y solamente est\u00e1n los resultados del proyecto (en <code>mkdocs.yml:nav</code>)</li> <li> Muestra las f\u00f3rmulas utilizadas en el desarrollo del proyecto</li> <li> Hay buena ortograf\u00eda, en general</li> <li> La redacci\u00f3n es buena, en general</li> <li> Coloca las variables en el texto y las f\u00f3rmulas de forma nativa en LaTeX</li> </ul>"},{"location":"requisitos/#analisis-de-datos","title":"An\u00e1lisis de datos","text":"<ul> <li> Hay una elecci\u00f3n de la distribuci\u00f3n y es apropiada o razonable</li> <li> El modelo de probabilidad de los datos es un modelo de distribuci\u00f3n estad\u00edstica y no un KDE (kernel density estimation)</li> <li> La determinaci\u00f3n de la distribuci\u00f3n de las variables es hecha con \"pruebas de bondad de ajuste\", como las que hace <code>fitter</code> (Py5), y no solamente con \"inspecci\u00f3n visual\"</li> <li> La documentaci\u00f3n especifica el modelo de la(s) tabla(s) utilizadas en la base de datos (ejemplo: <code>class TestData</code>)</li> <li> Adapta correctamente la escala horizontal (bins) del histograma de los datos</li> <li> La gr\u00e1ficas est\u00e1n bien rotuladas (nombres y unidades en los ejes, cuando aplica)</li> <li> Presenta una s\u00edntesis de los resultados num\u00e9ricos importantes en una tabla, cuando es pertinente</li> </ul>"},{"location":"requisitos/#codigo","title":"C\u00f3digo","text":"<ul> <li> El desarrollo del c\u00f3digo est\u00e1 ampliamente comentado</li> <li> Las variables tienen nombres pertinentes (claridad mata brevedad)</li> <li> Adopta la convenci\u00f3n de escritura de c\u00f3digo PEP 8</li> <li> Adopta la convenci\u00f3n de documentaci\u00f3n con docstrings PEP 257</li> </ul>"},{"location":"requisitos/#como-dar-formato-al-codigo","title":"C\u00f3mo dar formato al c\u00f3digo","text":"<p>La mejor recomendaci\u00f3n es instalar una extensi\u00f3n de formato autom\u00e1tico en el editor (como VS Code). Black o Ruff son buenos y recomendados. As\u00ed, ser\u00e1 posible dar formato autom\u00e1ticamente con, por ejemplo, <code>Alt</code> + <code>Shift</code> + <code>F</code>.</p> <p>El c\u00f3digo ser\u00e1 evaluado usando <code>$ flake8 &lt;archivo&gt;.py</code>, que devuelve una lista de errores (o violaciones a la norma) encontrados.</p>"}]}